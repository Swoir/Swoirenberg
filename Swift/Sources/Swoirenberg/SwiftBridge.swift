// File automatically generated by swift-bridge.
import SwoirenbergLib
public func setup_srs_swift<GenericToRustStr: ToRustStr>(_ circuit_size: UInt32, _ srs_path: Optional<GenericToRustStr>) -> Optional<UInt32> {
    return optionalRustStrToRustStr(srs_path, { srs_pathAsRustStr in
        __swift_bridge__$setup_srs_swift(circuit_size, srs_pathAsRustStr).intoSwiftRepr()
    })
}
public func setup_srs_from_bytecode_swift<GenericToRustStr: ToRustStr, GenericIntoRustString: IntoRustString>(_ circuit_bytecode: GenericIntoRustString, _ srs_path: Optional<GenericToRustStr>) -> Optional<UInt32> {
    return optionalRustStrToRustStr(srs_path, { srs_pathAsRustStr in
        __swift_bridge__$setup_srs_from_bytecode_swift({ let rustString = circuit_bytecode.intoRustString(); rustString.isOwned = false; return rustString.ptr }(), srs_pathAsRustStr).intoSwiftRepr()
    })
}
public func prove_swift<GenericIntoRustString: IntoRustString>(_ circuit_bytecode: GenericIntoRustString, _ initial_witness: RustVec<GenericIntoRustString>, _ proof_type: GenericIntoRustString, _ vkey: RustVec<UInt8>, _ low_memory_mode: Bool, _ storage_cap: UInt64) throws -> RustVec<UInt8> {
    try { let val = __swift_bridge__$prove_swift({ let rustString = circuit_bytecode.intoRustString(); rustString.isOwned = false; return rustString.ptr }(), { let val = initial_witness; val.isOwned = false; return val.ptr }(), { let rustString = proof_type.intoRustString(); rustString.isOwned = false; return rustString.ptr }(), { let val = vkey; val.isOwned = false; return val.ptr }(), low_memory_mode, storage_cap); if val.is_ok { return RustVec(ptr: val.ok_or_err!) } else { throw RustString(ptr: val.ok_or_err!) } }()
}
public func verify_swift<GenericIntoRustString: IntoRustString>(_ proof: RustVec<UInt8>, _ vkey: RustVec<UInt8>, _ proof_type: GenericIntoRustString) -> Optional<Bool> {
    __swift_bridge__$verify_swift({ let val = proof; val.isOwned = false; return val.ptr }(), { let val = vkey; val.isOwned = false; return val.ptr }(), { let rustString = proof_type.intoRustString(); rustString.isOwned = false; return rustString.ptr }()).intoSwiftRepr()
}
public func execute_swift<GenericIntoRustString: IntoRustString>(_ circuit_bytecode: GenericIntoRustString, _ initial_witness: RustVec<GenericIntoRustString>) throws -> RustVec<RustString> {
    try { let val = __swift_bridge__$execute_swift({ let rustString = circuit_bytecode.intoRustString(); rustString.isOwned = false; return rustString.ptr }(), { let val = initial_witness; val.isOwned = false; return val.ptr }()); if val.is_ok { return RustVec(ptr: val.ok_or_err!) } else { throw RustString(ptr: val.ok_or_err!) } }()
}
public func get_vkey_swift<GenericIntoRustString: IntoRustString>(_ circuit_bytecode: GenericIntoRustString, _ proof_type: GenericIntoRustString, _ low_memory_mode: Bool, _ storage_cap: UInt64) -> Optional<RustVec<UInt8>> {
    { let val = __swift_bridge__$get_vkey_swift({ let rustString = circuit_bytecode.intoRustString(); rustString.isOwned = false; return rustString.ptr }(), { let rustString = proof_type.intoRustString(); rustString.isOwned = false; return rustString.ptr }(), low_memory_mode, storage_cap); if val != nil { return RustVec(ptr: val!) } else { return nil } }()
}


